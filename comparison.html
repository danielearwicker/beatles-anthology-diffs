<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Beatles Anthology - DVD vs Disney+ Comparison</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                    Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                background: #1a1a1a;
                color: #e0e0e0;
                padding: 20px;
                line-height: 1.6;
            }

            h1 {
                text-align: center;
                margin-bottom: 15px;
                color: #fff;
                font-size: 2em;
            }

            a {
                color: #4caf50;
            }

            .episode-nav {
                text-align: center;
                margin-bottom: 30px;
                display: flex;
                justify-content: center;
                gap: 15px;
                flex-wrap: wrap;
            }

            .episode-link {
                display: inline-block;
                padding: 8px 16px;
                background: #2a2a2a;
                color: #e0e0e0;
                text-decoration: none;
                border-radius: 6px;
                border: 2px solid #555;
                transition: all 0.2s;
                font-weight: 500;
            }

            .episode-link:hover {
                background: #333;
                border-color: #4caf50;
                transform: translateY(-2px);
            }

            .episode-link.active {
                background: #4caf50;
                border-color: #4caf50;
                color: #1a1a1a;
                font-weight: bold;
            }

            p {
                margin: 10px 0;
            }

            .debug-indicator {
                display: inline-block;
                background: #ff6b6b;
                color: white;
                padding: 4px 12px;
                border-radius: 4px;
                font-size: 0.5em;
                margin-left: 15px;
                vertical-align: middle;
            }

            .container {
                max-width: 1800px;
                margin: 0 auto;
                position: relative;
            }

            .columns {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 100px;
                position: relative;
            }

            .column {
                position: relative;
            }

            #dvd-content,
            #dplus-content {
                position: relative;
            }

            #dvd-content > div,
            #dplus-content > div {
                position: absolute;
                left: 0;
                right: 0;
            }

            .column-header {
                position: sticky;
                top: 0;
                background: #1a1a1a;
                padding: 15px 20px;
                margin-bottom: 20px;
                border-bottom: 2px solid #4caf50;
                z-index: 10;
                font-weight: bold;
                font-size: 1.2em;
            }

            .dvd-header {
                border-bottom-color: #2196f3;
            }

            .dplus-header {
                border-bottom-color: #ff9800;
            }

            .entry {
                background: #2a2a2a;
                padding: 15px;
                margin-bottom: 12px;
                border-radius: 6px;
                border-left: 4px solid #555;
                transition: all 0.2s;
            }

            .entry:hover {
                background: #333;
                transform: translateX(2px);
            }

            .dvd .entry {
                border-left-color: #2196f3;
            }

            .dplus .entry {
                border-left-color: #ff9800;
            }

            .entry.matched {
                border-left-width: 6px;
                cursor: pointer;
            }

            .entry.dropped {
                background: rgba(139, 0, 0, 0.15);
            }

            .entry.dropped:hover {
                background: rgba(139, 0, 0, 0.25);
            }

            .entry.added {
                background: rgba(0, 100, 0, 0.15);
            }

            .entry.added:hover {
                background: rgba(0, 100, 0, 0.25);
            }

            .timecode {
                font-weight: bold;
                color: #4caf50;
                font-family: "Courier New", monospace;
                margin-bottom: 8px;
                font-size: 0.95em;
            }

            .content {
                color: #e0e0e0;
            }

            .content em {
                color: #ffd700;
                font-style: italic;
            }

            .content strong {
                color: #ff6b6b;
                font-weight: bold;
            }

            .content a {
                color: #4caf50;
                text-decoration: underline;
                cursor: pointer;
                transition: color 0.2s;
            }

            .content a:hover {
                color: #66bb6a;
            }

            #arrow-layer {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 1;
            }

            .arrow-line {
                fill: none;
                stroke: #4caf50;
                stroke-width: 2;
                opacity: 0.6;
                transition: opacity 0.2s;
            }

            .arrow-line.strong-match {
                stroke: #ffd700;
                stroke-width: 3;
                opacity: 0.8;
            }

            .arrow-line.dimmed {
                opacity: 0.1 !important;
            }

            .arrow-line.highlighted {
                opacity: 1 !important;
                stroke-width: 4 !important;
            }

            .entry.highlight-target {
                background: #3a3a3a;
                box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
            }

            .loading {
                text-align: center;
                padding: 50px;
                font-size: 1.2em;
                color: #888;
            }

            .error {
                background: #d32f2f;
                color: white;
                padding: 20px;
                border-radius: 6px;
                margin: 20px;
            }

            @media (max-width: 1200px) {
                .columns {
                    gap: 40px;
                }
            }
        </style>
    </head>
    <body>
        <h1>Beatles Anthology - DVD vs Disney+ Comparison</h1>
        <nav class="episode-nav" id="episode-nav">
            <a href="#" class="episode-link" data-episode="1">Episode 1</a>
            <a href="#2" class="episode-link" data-episode="2">Episode 2</a>
            <a href="#3" class="episode-link" data-episode="3">Episode 3</a>
            <a href="#4" class="episode-link" data-episode="4">Episode 4</a>
            <a href="#5" class="episode-link" data-episode="5">Episode 5</a>
        </nav>
        <p>
            Are you wondering how has the Beatles Anthology documentary changed
            between the 2003 DVD version and the 2025 Disney+ version? Here is
            an attempt to answer that question.
        </p>
        <p>
            This is not a complete transcript. It includes items removed from
            the original DVD version (dark red items on the left) or added to
            the Disney+ version (dark green items on the right), and also some
            items reordered or modified which are connected by links. You can
            click on an item to follow the link to see where it appears in the
            other version.
        </p>
        <p>
            There are many changes that apply across the whole series,
            especially the widespread use of AI to clean up footage and emulate
            detail, and the elimination of fades between clips.
        </p>
        <p>
            <a href="https://github.com/danielearwicker/beatles-anthology-diffs"
                >Source on Github</a
            >
        </p>
        <div class="loading" id="loading">Loading transcripts...</div>
        <div class="container" id="container" style="display: none">
            <svg id="arrow-layer"></svg>
            <div class="columns">
                <div class="column dvd">
                    <div class="column-header dvd-header">2003 DVD Version</div>
                    <div id="dvd-content"></div>
                </div>
                <div class="column dplus">
                    <div class="column-header dplus-header">
                        2025 Disney+ Version
                    </div>
                    <div id="dplus-content"></div>
                </div>
            </div>
        </div>

        <script>
            // DEBUG: Set to true to show index numbers next to entries
            const SHOW_INDICES = false;

            // Parse episode and item from URL hash
            // Format: #dvd54 (episode 1, backward compat), #2 (episode 2), or #3&dvd54 (episode 3, item dvd54)
            function parseHash(hash) {
                if (!hash) return { episode: 1, itemId: null };

                const cleaned = hash.startsWith("#") ? hash.substring(1) : hash;

                if (cleaned.includes("&")) {
                    // Format: #3&dvd54
                    const [episodeStr, itemId] = cleaned.split("&");
                    return {
                        episode: parseInt(episodeStr) || 1,
                        itemId: itemId || null,
                    };
                } else if (/^\d+$/.test(cleaned)) {
                    // Just a number: treat as episode number (e.g., #2)
                    return {
                        episode: parseInt(cleaned) || 1,
                        itemId: null,
                    };
                } else {
                    // Backward compat: no ampersand and not just a number means episode 1 with itemId
                    return {
                        episode: 1,
                        itemId: cleaned || null,
                    };
                }
            }

            // Format episode and item into URL hash
            function formatHash(episode, itemId) {
                if (episode === 1) {
                    // Episode 1: use backward-compatible format (no episode number)
                    return itemId ? `#${itemId}` : "";
                } else {
                    // Other episodes: include episode number
                    return itemId ? `#${episode}&${itemId}` : `#${episode}`;
                }
            }

            class TranscriptParser {
                parse(text) {
                    const lines = text.split("\n");
                    const entries = [];
                    let currentEntry = null;

                    for (let line of lines) {
                        line = line.trim();

                        // Skip title and empty lines
                        if (!line || line.startsWith("Anthology,")) continue;

                        // Check if this is a timecode line (supports both MM:SS and HH:MM:SS)
                        const timecodeMatch = line.match(
                            /^(\d{1,2}:\d{2}(?::\d{2})?)/
                        );

                        if (timecodeMatch) {
                            // Save previous entry if it exists
                            if (currentEntry) {
                                entries.push(currentEntry);
                            }

                            // Start new entry
                            currentEntry = {
                                timecode: timecodeMatch[1],
                                content: line
                                    .substring(timecodeMatch[0].length)
                                    .trim(),
                            };
                        } else if (currentEntry && line.startsWith("-")) {
                            // This is a continuation (like photo differences)
                            currentEntry.content += "\n" + line;
                        }
                    }

                    // Don't forget the last entry
                    if (currentEntry) {
                        entries.push(currentEntry);
                    }

                    return entries;
                }

                formatContent(text) {
                    // Convert markdown-like formatting to HTML
                    return text
                        .replace(
                            /\[([^\]]+)\]\(#([^)]+)\)/g,
                            '<a href="#$2">$1</a>'
                        ) // Links
                        .replace(/_([^_]+)_/g, "<em>$1</em>") // Italics
                        .replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>") // Bold
                        .replace(/\[edit\]/g, "<strong>[edit]</strong>")
                        .replace(/\n/g, "<br>");
                }
            }

            class TranscriptRenderer {
                constructor(container, episode = 1) {
                    this.container = container;
                    this.episode = episode;
                    this.dvdContent = document.getElementById("dvd-content");
                    this.dplusContent =
                        document.getElementById("dplus-content");
                    this.arrowLayer = document.getElementById("arrow-layer");
                    this.parser = new TranscriptParser();
                }

                async loadFile(filename) {
                    const response = await fetch(filename);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${filename}`);
                    }
                    return await response.text();
                }

                renderEntry(entry, index, column) {
                    const div = document.createElement("div");
                    div.className = "entry";
                    div.dataset.index = index;
                    div.dataset.column = column;
                    div.id = `${column}${index}`; // Add ID for deep linking

                    const timecode = document.createElement("div");
                    timecode.className = "timecode";

                    // Optionally show index number for debugging
                    if (SHOW_INDICES) {
                        const indexBadge = document.createElement("span");
                        indexBadge.style.cssText =
                            "background: #555; padding: 2px 6px; border-radius: 3px; margin-right: 8px; font-size: 0.85em;";
                        indexBadge.textContent = `#${index}`;
                        timecode.appendChild(indexBadge);
                    }

                    const timecodeText = document.createTextNode(
                        entry.timecode
                    );
                    timecode.appendChild(timecodeText);

                    const content = document.createElement("div");
                    content.className = "content";
                    content.innerHTML = this.parser.formatContent(
                        entry.content
                    );

                    div.appendChild(timecode);
                    div.appendChild(content);

                    return div;
                }

                renderEntries(entries, container, column) {
                    entries.forEach((entry, index) => {
                        const entryDiv = this.renderEntry(entry, index, column);
                        container.appendChild(entryDiv);
                    });
                }

                alignAndDrawArrows(matches, dvdCount, dplusCount) {
                    // Collect all elements
                    const dvdElements = [];
                    const dplusElements = [];
                    const MARGIN = 12;

                    for (let i = 0; i < dvdCount; i++) {
                        const el = this.dvdContent.querySelector(
                            `[data-index="${i}"]`
                        );
                        dvdElements.push(el);
                    }

                    for (let i = 0; i < dplusCount; i++) {
                        const el = this.dplusContent.querySelector(
                            `[data-index="${i}"]`
                        );
                        dplusElements.push(el);
                    }

                    // Clear all absolute positions to get natural layout
                    dvdElements.forEach((el) => {
                        if (el) el.style.top = "";
                    });
                    dplusElements.forEach((el) => {
                        if (el) el.style.top = "";
                    });

                    // Force reflow to get accurate heights after text reflow
                    void this.dvdContent.offsetHeight;
                    void this.dplusContent.offsetHeight;

                    // Now measure heights with natural layout
                    const dvdHeights = [];
                    const dplusHeights = [];

                    for (let i = 0; i < dvdCount; i++) {
                        const height = dvdElements[i]
                            ? dvdElements[i].offsetHeight
                            : 0;
                        dvdHeights.push(height);
                        // Check for NaN heights
                        if (
                            isNaN(height) ||
                            height === undefined ||
                            height === null
                        ) {
                            console.error(
                                `DVD height[${i}] is invalid:`,
                                height,
                                "element:",
                                dvdElements[i]
                            );
                        }
                    }

                    for (let i = 0; i < dplusCount; i++) {
                        const height = dplusElements[i]
                            ? dplusElements[i].offsetHeight
                            : 0;
                        dplusHeights.push(height);
                        if (
                            isNaN(height) ||
                            height === undefined ||
                            height === null
                        ) {
                            console.error(
                                `D+ height[${i}] is invalid:`,
                                height,
                                "element:",
                                dplusElements[i]
                            );
                        }
                    }

                    // Log heights around the problem area
                    console.log(
                        "DVD heights [84-89]:",
                        dvdHeights.slice(84, 90)
                    );

                    // Build sets of matched indices
                    const dvdMatchedSet = new Set(matches.map((m) => m.dvd));
                    const dplusMatchedSet = new Set(
                        matches.map((m) => m.dplus)
                    );

                    // Mark matched entries
                    matches.forEach((match) => {
                        if (dvdElements[match.dvd])
                            dvdElements[match.dvd].classList.add("matched");
                        if (dplusElements[match.dplus])
                            dplusElements[match.dplus].classList.add("matched");
                    });

                    // Mark dropped/added entries
                    for (let i = 0; i < dvdCount; i++) {
                        if (!dvdMatchedSet.has(i) && dvdElements[i]) {
                            dvdElements[i].classList.add("dropped");
                        }
                    }
                    for (let i = 0; i < dplusCount; i++) {
                        if (!dplusMatchedSet.has(i) && dplusElements[i]) {
                            dplusElements[i].classList.add("added");
                        }
                    }

                    // Filter to monotonic matches
                    const monotonic = [];
                    let lastDvd = -1;
                    let lastDplus = -1;

                    const sortedMatches = [...matches].sort(
                        (a, b) => a.dvd - b.dvd
                    );

                    sortedMatches.forEach((match) => {
                        const isForced = match.aligned === true;
                        const isMonotonic =
                            match.dvd > lastDvd && match.dplus > lastDplus;

                        if (isForced || isMonotonic) {
                            monotonic.push(match);
                            if (isMonotonic) {
                                lastDvd = match.dvd;
                                lastDplus = match.dplus;
                            }
                        }
                    });

                    // Filter to alignment matches (skip isolated/problematic ones)
                    const alignmentMatches = [];
                    const diagnostics = [];

                    for (let i = 0; i < monotonic.length; i++) {
                        const current = monotonic[i];
                        const prev = monotonic[i - 1];
                        const next = monotonic[i + 1];

                        const dvdGapBefore = prev
                            ? current.dvd - prev.dvd - 1
                            : current.dvd;
                        const dplusGapBefore = prev
                            ? current.dplus - prev.dplus - 1
                            : current.dplus;
                        const dvdGapAfter = next
                            ? next.dvd - current.dvd - 1
                            : dvdCount - current.dvd - 1;
                        const dplusGapAfter = next
                            ? next.dplus - current.dplus - 1
                            : dplusCount - current.dplus - 1;

                        const mismatchBefore = Math.abs(
                            dvdGapBefore - dplusGapBefore
                        );
                        const mismatchAfter = Math.abs(
                            dvdGapAfter - dplusGapAfter
                        );
                        const totalMismatch = mismatchBefore + mismatchAfter;

                        const windowSize = 10;
                        let nearbyMatches = 0;
                        for (
                            let j = Math.max(0, i - windowSize);
                            j < Math.min(monotonic.length, i + windowSize);
                            j++
                        ) {
                            if (j !== i) nearbyMatches++;
                        }

                        const isIsolated = nearbyMatches < 2;
                        const hasModerateMismatch = totalMismatch > 10;
                        const hasLargeMismatch = totalMismatch > 12;
                        const isForced = current.aligned === true;

                        const shouldSkip =
                            !isForced &&
                            (hasLargeMismatch ||
                                (isIsolated && hasModerateMismatch));

                        diagnostics.push({
                            dvd: current.dvd,
                            dplus: current.dplus,
                            totalMismatch,
                            nearbyMatches,
                            isForced,
                            decision: shouldSkip
                                ? "SKIP"
                                : isForced
                                ? "FORCED"
                                : "ALIGN",
                        });

                        if (!shouldSkip) {
                            alignmentMatches.push(current);
                        }
                    }

                    // Sort alignment matches
                    const sortedAlignments = [...alignmentMatches].sort(
                        (a, b) => {
                            if (a.dvd !== b.dvd) return a.dvd - b.dvd;
                            return a.dplus - b.dplus;
                        }
                    );

                    // Check if any mappings reference indices beyond our counts
                    const maxDvdIndex = Math.max(...matches.map((m) => m.dvd));
                    const maxDplusIndex = Math.max(
                        ...matches.map((m) => m.dplus)
                    );
                    console.log(
                        `Max mapped indices: DVD=${maxDvdIndex}, D+=${maxDplusIndex}`
                    );
                    console.log(
                        `Actual counts: DVD=${dvdCount}, D+=${dplusCount}`
                    );

                    if (maxDvdIndex >= dvdCount) {
                        console.error(
                            `⚠️ Mapping references DVD index ${maxDvdIndex} but only have ${dvdCount} entries!`
                        );
                    }
                    if (maxDplusIndex >= dplusCount) {
                        console.error(
                            `⚠️ Mapping references D+ index ${maxDplusIndex} but only have ${dplusCount} entries!`
                        );
                    }

                    // Calculate absolute positions
                    const dvdPositions = new Array(dvdCount).fill(0);
                    const dplusPositions = new Array(dplusCount).fill(0);

                    let dvdCurrentTop = 0;
                    let dplusCurrentTop = 0;
                    let lastDvdIdx = -1;
                    let lastDplusIdx = -1;

                    sortedAlignments.forEach((match, matchNum) => {
                        // Skip backwards alignments
                        if (
                            match.dvd <= lastDvdIdx ||
                            match.dplus <= lastDplusIdx
                        ) {
                            console.warn(
                                `⚠️ Skipping out-of-order: DVD ${match.dvd} → D+ ${match.dplus}`
                            );
                            return;
                        }

                        // Position items between last alignment and this one
                        for (let i = lastDvdIdx + 1; i < match.dvd; i++) {
                            dvdPositions[i] = dvdCurrentTop;
                            dvdCurrentTop += dvdHeights[i] + MARGIN;
                            // Check for NaN propagation
                            if (isNaN(dvdCurrentTop)) {
                                console.error(
                                    `NaN detected at DVD[${i}]: height=${
                                        dvdHeights[i]
                                    }, was ${
                                        dvdCurrentTop - dvdHeights[i] - MARGIN
                                    }, added ${dvdHeights[i]} + ${MARGIN}`
                                );
                            }
                        }
                        for (let i = lastDplusIdx + 1; i < match.dplus; i++) {
                            dplusPositions[i] = dplusCurrentTop;
                            dplusCurrentTop += dplusHeights[i] + MARGIN;
                        }

                        // Align the matched items at the same top position
                        const alignTop = Math.max(
                            dvdCurrentTop,
                            dplusCurrentTop
                        );
                        dvdPositions[match.dvd] = alignTop;
                        dplusPositions[match.dplus] = alignTop;

                        // Advance both sides
                        const dvdHeight = dvdHeights[match.dvd];
                        const dplusHeight = dplusHeights[match.dplus];

                        if (isNaN(dvdHeight) || dvdHeight === undefined) {
                            console.error(
                                `Match ${matchNum}: DVD height[${match.dvd}] is invalid:`,
                                dvdHeight
                            );
                        }
                        if (isNaN(dplusHeight) || dplusHeight === undefined) {
                            console.error(
                                `Match ${matchNum}: D+ height[${match.dplus}] is invalid:`,
                                dplusHeight
                            );
                        }

                        dvdCurrentTop = alignTop + dvdHeight + MARGIN;
                        dplusCurrentTop = alignTop + dplusHeight + MARGIN;

                        if (isNaN(dvdCurrentTop)) {
                            console.error(
                                `NaN after match ${matchNum} (DVD ${match.dvd}): alignTop=${alignTop}, height=${dvdHeight}`
                            );
                        }

                        lastDvdIdx = match.dvd;
                        lastDplusIdx = match.dplus;
                    });

                    // Position remaining items after last alignment
                    for (let i = lastDvdIdx + 1; i < dvdCount; i++) {
                        dvdPositions[i] = dvdCurrentTop;
                        dvdCurrentTop += dvdHeights[i] + MARGIN;
                    }
                    for (let i = lastDplusIdx + 1; i < dplusCount; i++) {
                        dplusPositions[i] = dplusCurrentTop;
                        dplusCurrentTop += dplusHeights[i] + MARGIN;
                    }

                    // Apply absolute positions
                    console.log(
                        `Applying positions: DVD count=${dvdCount}, positions length=${dvdPositions.length}`
                    );
                    console.log(`Last DVD index: ${lastDvdIdx}`);

                    // Check if positions after index 85 are being set
                    const positionsAfter85 = dvdPositions.slice(86, 90);
                    console.log("DVD positions [86-89]:", positionsAfter85);

                    let missingCount = 0;
                    dvdElements.forEach((el, i) => {
                        if (el) {
                            if (dvdPositions[i] === undefined) {
                                console.error(
                                    `DVD position[${i}] is undefined!`
                                );
                                missingCount++;
                            } else {
                                el.style.top = dvdPositions[i] + "px";
                                // Log a few examples
                                if (i >= 84 && i <= 88) {
                                    console.log(
                                        `Set DVD[${i}].style.top = ${dvdPositions[i]}px`
                                    );
                                }
                            }
                        } else {
                            console.warn(`DVD element[${i}] is null/undefined`);
                        }
                    });

                    if (missingCount > 0) {
                        console.error(
                            `${missingCount} DVD positions were undefined!`
                        );
                    }

                    dplusElements.forEach((el, i) => {
                        if (el) {
                            el.style.top = dplusPositions[i] + "px";
                        }
                    });

                    // Set minimum heights on containers
                    const dvdTotalHeight =
                        Math.max(...dvdPositions) +
                        (dvdHeights[dvdCount - 1] || 0);
                    const dplusTotalHeight =
                        Math.max(...dplusPositions) +
                        (dplusHeights[dplusCount - 1] || 0);
                    this.dvdContent.style.minHeight = dvdTotalHeight + "px";
                    this.dplusContent.style.minHeight = dplusTotalHeight + "px";

                    // Force a reflow to ensure positions are applied before measuring for arrows
                    void this.dvdContent.offsetHeight;
                    void this.dplusContent.offsetHeight;

                    // Draw arrows after one animation frame to ensure paint is complete
                    requestAnimationFrame(() => {
                        // Force one more reflow before measuring element positions
                        void this.dvdContent.offsetHeight;
                        void this.dplusContent.offsetHeight;

                        this.drawArrows(matches);
                        this.setupInteractions(matches);
                    });
                }

                drawArrows(matches) {
                    // Clear existing arrows
                    this.arrowLayer.innerHTML = "";

                    const containerRect =
                        this.container.getBoundingClientRect();
                    const columnsEl = document.querySelector(".columns");
                    const columnsRect = columnsEl.getBoundingClientRect();

                    // Set SVG dimensions
                    this.arrowLayer.setAttribute("width", columnsRect.width);
                    this.arrowLayer.setAttribute("height", columnsRect.height);
                    this.arrowLayer.style.left =
                        columnsRect.left - containerRect.left + "px";
                    this.arrowLayer.style.top =
                        columnsRect.top - containerRect.top + "px";

                    matches.forEach((match) => {
                        const dvdEl = this.dvdContent.querySelector(
                            `[data-index="${match.dvd}"]`
                        );
                        const dplusEl = this.dplusContent.querySelector(
                            `[data-index="${match.dplus}"]`
                        );

                        if (!dvdEl || !dplusEl) return;

                        const dvdRect = dvdEl.getBoundingClientRect();
                        const dplusRect = dplusEl.getBoundingClientRect();

                        // Calculate positions relative to columns container
                        const x1 = dvdRect.right - columnsRect.left;
                        const y1 =
                            dvdRect.top - columnsRect.top + dvdRect.height / 2;
                        const x2 = dplusRect.left - columnsRect.left;
                        const y2 =
                            dplusRect.top -
                            columnsRect.top +
                            dplusRect.height / 2;

                        // Create curved path
                        const midX = (x1 + x2) / 2;
                        const path = document.createElementNS(
                            "http://www.w3.org/2000/svg",
                            "path"
                        );
                        const d = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
                        path.setAttribute("d", d);

                        // Color code by match type
                        const className =
                            match.matchType === "same"
                                ? "arrow-line strong-match"
                                : "arrow-line";
                        path.setAttribute("class", className);

                        // Store connection info for hover/click interactions
                        path.setAttribute("data-dvd", match.dvd);
                        path.setAttribute("data-dplus", match.dplus);

                        this.arrowLayer.appendChild(path);
                    });
                }

                setupInteractions(matches) {
                    const allEntries = document.querySelectorAll(".entry");
                    const allArrows =
                        this.arrowLayer.querySelectorAll(".arrow-line");

                    // Build lookup maps for which arrows connect to which entries
                    const dvdToArrows = {};
                    const dplusToArrows = {};

                    allArrows.forEach((arrow) => {
                        const dvdIdx = arrow.getAttribute("data-dvd");
                        const dplusIdx = arrow.getAttribute("data-dplus");

                        if (!dvdToArrows[dvdIdx]) dvdToArrows[dvdIdx] = [];
                        if (!dplusToArrows[dplusIdx])
                            dplusToArrows[dplusIdx] = [];

                        dvdToArrows[dvdIdx].push(arrow);
                        dplusToArrows[dplusIdx].push(arrow);
                    });

                    // Build lookup map for corresponding entries
                    const dvdToDplus = {};
                    const dplusToDvd = {};

                    matches.forEach((match) => {
                        if (!dvdToDplus[match.dvd]) dvdToDplus[match.dvd] = [];
                        if (!dplusToDvd[match.dplus])
                            dplusToDvd[match.dplus] = [];

                        dvdToDplus[match.dvd].push(match.dplus);
                        dplusToDvd[match.dplus].push(match.dvd);
                    });

                    // Add hover and click listeners to all entries
                    allEntries.forEach((entry) => {
                        const index = entry.dataset.index;
                        const column = entry.dataset.column;

                        // Hover to highlight arrows
                        entry.addEventListener("mouseenter", () => {
                            const relevantArrows =
                                column === "dvd"
                                    ? dvdToArrows[index]
                                    : dplusToArrows[index];

                            if (relevantArrows && relevantArrows.length > 0) {
                                // Dim all arrows
                                allArrows.forEach((arrow) =>
                                    arrow.classList.add("dimmed")
                                );
                                // Highlight relevant arrows
                                relevantArrows.forEach((arrow) => {
                                    arrow.classList.remove("dimmed");
                                    arrow.classList.add("highlighted");
                                });
                            }
                        });

                        entry.addEventListener("mouseleave", () => {
                            // Remove all highlighting
                            allArrows.forEach((arrow) => {
                                arrow.classList.remove("dimmed");
                                arrow.classList.remove("highlighted");
                            });
                        });

                        // Click to scroll to corresponding entry (or self if unmatched)
                        entry.addEventListener("click", (e) => {
                            // Don't interfere with links inside the entry
                            if (
                                e.target.tagName === "A" ||
                                e.target.closest("a")
                            ) {
                                return;
                            }

                            const correspondingIndices =
                                column === "dvd"
                                    ? dvdToDplus[index]
                                    : dplusToDvd[index];

                            if (
                                correspondingIndices &&
                                correspondingIndices.length > 0
                            ) {
                                // Has a match - scroll to the first corresponding entry
                                const targetIndex = correspondingIndices[0];
                                const targetColumn =
                                    column === "dvd" ? "dplus" : "dvd";
                                const targetEl = document.querySelector(
                                    `[data-index="${targetIndex}"][data-column="${targetColumn}"]`
                                );

                                if (targetEl) {
                                    // Remove previous highlight
                                    document
                                        .querySelectorAll(".highlight-target")
                                        .forEach((el) => {
                                            el.classList.remove(
                                                "highlight-target"
                                            );
                                        });

                                    // Add highlight to target
                                    targetEl.classList.add("highlight-target");

                                    // Update URL hash for deep linking
                                    window.history.replaceState(
                                        null,
                                        null,
                                        formatHash(this.episode, targetEl.id)
                                    );

                                    // Scroll to center
                                    targetEl.scrollIntoView({
                                        behavior: "smooth",
                                        block: "center",
                                    });

                                    // Remove highlight after 2 seconds
                                    setTimeout(() => {
                                        targetEl.classList.remove(
                                            "highlight-target"
                                        );
                                    }, 2000);
                                }
                            } else {
                                // No match - just update hash to this item
                                window.history.replaceState(
                                    null,
                                    null,
                                    formatHash(this.episode, entry.id)
                                );
                            }
                        });
                    });

                    // Handle clicks on links within entry content
                    document.querySelectorAll(".content a").forEach((link) => {
                        link.addEventListener("click", (e) => {
                            e.preventDefault();
                            const hash = link.getAttribute("href");

                            if (hash && hash.startsWith("#")) {
                                const { episode: targetEpisode, itemId } =
                                    parseHash(hash);

                                if (targetEpisode !== this.episode) {
                                    // Different episode - reload page with new episode
                                    window.location.hash = hash.substring(1); // Remove leading #
                                    window.location.reload();
                                } else if (itemId) {
                                    // Same episode - scroll to target
                                    const targetEl =
                                        document.getElementById(itemId);
                                    if (targetEl) {
                                        targetEl.classList.add(
                                            "highlight-target"
                                        );
                                        targetEl.scrollIntoView({
                                            behavior: "smooth",
                                            block: "center",
                                        });
                                        // Update URL hash
                                        window.history.replaceState(
                                            null,
                                            null,
                                            hash
                                        );
                                        setTimeout(() => {
                                            targetEl.classList.remove(
                                                "highlight-target"
                                            );
                                        }, 2000);
                                    }
                                }
                            }
                        });
                    });
                }

                async render() {
                    try {
                        // Load both transcript files and mapping for this episode
                        const [dvdText, dplusText, mappingResponse] =
                            await Promise.all([
                                this.loadFile(`${this.episode}-dvd.md`),
                                this.loadFile(`${this.episode}-dplus.md`),
                                fetch(`${this.episode}-mapping.json`),
                            ]);

                        const mappingData = await mappingResponse.json();
                        const matches = mappingData.mappings;

                        console.log(`Loading Episode ${this.episode}`);

                        // Parse entries
                        const dvdEntries = this.parser.parse(dvdText);
                        const dplusEntries = this.parser.parse(dplusText);

                        console.log(
                            `DVD entries: ${dvdEntries.length}, Disney+ entries: ${dplusEntries.length}`
                        );
                        console.log(
                            `Loaded ${matches.length} matches from mapping file`
                        );

                        // Render entries
                        this.renderEntries(dvdEntries, this.dvdContent, "dvd");
                        this.renderEntries(
                            dplusEntries,
                            this.dplusContent,
                            "dplus"
                        );

                        // Hide loading, show content
                        document.getElementById("loading").style.display =
                            "none";
                        this.container.style.display = "block";

                        // Align and draw arrows after render
                        // (setupInteractions is called automatically after arrows are drawn)
                        setTimeout(() => {
                            this.alignAndDrawArrows(
                                matches,
                                dvdEntries.length,
                                dplusEntries.length
                            );

                            // Handle deep linking from URL hash
                            setTimeout(() => {
                                if (window.location.hash) {
                                    const { itemId } = parseHash(
                                        window.location.hash
                                    );
                                    if (itemId) {
                                        const targetEl =
                                            document.getElementById(itemId);
                                        if (targetEl) {
                                            targetEl.classList.add(
                                                "highlight-target"
                                            );
                                            targetEl.scrollIntoView({
                                                behavior: "smooth",
                                                block: "center",
                                            });
                                            setTimeout(() => {
                                                targetEl.classList.remove(
                                                    "highlight-target"
                                                );
                                            }, 3000);
                                        }
                                    }
                                }
                            }, 500);
                        }, 100);

                        // Recalculate positions and redraw arrows on window resize
                        let resizeTimeout;
                        window.addEventListener("resize", () => {
                            clearTimeout(resizeTimeout);
                            resizeTimeout = setTimeout(() => {
                                this.alignAndDrawArrows(
                                    matches,
                                    dvdEntries.length,
                                    dplusEntries.length
                                );
                            }, 200);
                        });
                    } catch (error) {
                        document.getElementById(
                            "loading"
                        ).innerHTML = `<div class="error">Error: ${error.message}</div>`;
                        console.error(error);
                    }
                }
            }

            // Initialize when page loads
            window.addEventListener("DOMContentLoaded", () => {
                // Add debug indicator to title if enabled
                if (SHOW_INDICES) {
                    const h1 = document.querySelector("h1");
                    const indicator = document.createElement("span");
                    indicator.className = "debug-indicator";
                    indicator.textContent = "DEBUG MODE";
                    h1.appendChild(indicator);
                }

                // Parse episode from URL hash
                const { episode } = parseHash(window.location.hash);

                // Highlight the active episode link
                document.querySelectorAll(".episode-link").forEach((link) => {
                    const linkEpisode = parseInt(
                        link.getAttribute("data-episode")
                    );
                    if (linkEpisode === episode) {
                        link.classList.add("active");
                    }
                });

                // Handle episode link clicks
                document.querySelectorAll(".episode-link").forEach((link) => {
                    link.addEventListener("click", (e) => {
                        e.preventDefault();
                        const targetEpisode = parseInt(
                            link.getAttribute("data-episode")
                        );
                        // Navigate to the new episode
                        window.location.hash =
                            targetEpisode === 1 ? "" : `#${targetEpisode}`;
                        window.location.reload();
                    });
                });

                const renderer = new TranscriptRenderer(
                    document.getElementById("container"),
                    episode
                );
                renderer.render();
            });
        </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Beatles Anthology - DVD vs Disney+ Comparison</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                    Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                background: #1a1a1a;
                color: #e0e0e0;
                padding: 20px;
                line-height: 1.6;
            }

            h1 {
                text-align: center;
                margin-bottom: 30px;
                color: #fff;
                font-size: 2em;
            }

            .debug-indicator {
                display: inline-block;
                background: #ff6b6b;
                color: white;
                padding: 4px 12px;
                border-radius: 4px;
                font-size: 0.5em;
                margin-left: 15px;
                vertical-align: middle;
            }

            .container {
                max-width: 1800px;
                margin: 0 auto;
                position: relative;
            }

            .columns {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 60px;
                position: relative;
            }

            .column {
                position: relative;
            }

            .column-header {
                position: sticky;
                top: 0;
                background: #1a1a1a;
                padding: 15px 20px;
                margin-bottom: 20px;
                border-bottom: 2px solid #4caf50;
                z-index: 10;
                font-weight: bold;
                font-size: 1.2em;
            }

            .dvd-header {
                border-bottom-color: #2196f3;
            }

            .dplus-header {
                border-bottom-color: #ff9800;
            }

            .entry {
                background: #2a2a2a;
                padding: 15px;
                margin-bottom: 12px;
                border-radius: 6px;
                border-left: 4px solid #555;
                transition: all 0.2s;
            }

            .entry:hover {
                background: #333;
                transform: translateX(2px);
            }

            .dvd .entry {
                border-left-color: #2196f3;
            }

            .dplus .entry {
                border-left-color: #ff9800;
            }

            .entry.matched {
                border-left-width: 6px;
                cursor: pointer;
            }

            .timecode {
                font-weight: bold;
                color: #4caf50;
                font-family: "Courier New", monospace;
                margin-bottom: 8px;
                font-size: 0.95em;
            }

            .content {
                color: #e0e0e0;
            }

            .content em {
                color: #ffd700;
                font-style: italic;
            }

            .content strong {
                color: #ff6b6b;
                font-weight: bold;
            }

            .spacer {
                height: 0;
                transition: height 0.3s;
            }

            #arrow-layer {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 1;
            }

            .arrow-line {
                fill: none;
                stroke: #4caf50;
                stroke-width: 2;
                opacity: 0.6;
                transition: opacity 0.2s;
            }

            .arrow-line.strong-match {
                stroke: #ffd700;
                stroke-width: 3;
                opacity: 0.8;
            }

            .arrow-line.dimmed {
                opacity: 0.1 !important;
            }

            .arrow-line.highlighted {
                opacity: 1 !important;
                stroke-width: 4 !important;
            }

            .entry.highlight-target {
                background: #3a3a3a;
                box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
            }

            .loading {
                text-align: center;
                padding: 50px;
                font-size: 1.2em;
                color: #888;
            }

            .error {
                background: #d32f2f;
                color: white;
                padding: 20px;
                border-radius: 6px;
                margin: 20px;
            }

            @media (max-width: 1200px) {
                .columns {
                    gap: 40px;
                }
            }
        </style>
    </head>
    <body>
        <h1>Beatles Anthology Episode 1 - Comparison</h1>
        <div class="loading" id="loading">Loading transcripts...</div>
        <div class="container" id="container" style="display: none">
            <svg id="arrow-layer"></svg>
            <div class="columns">
                <div class="column dvd">
                    <div class="column-header dvd-header">2003 DVD Version</div>
                    <div id="dvd-content"></div>
                </div>
                <div class="column dplus">
                    <div class="column-header dplus-header">
                        2025 Disney+ Version
                    </div>
                    <div id="dplus-content"></div>
                </div>
            </div>
        </div>

        <script>
            // DEBUG: Set to true to show index numbers next to entries
            const SHOW_INDICES = false;

            class TranscriptParser {
                parse(text) {
                    const lines = text.split("\n");
                    const entries = [];
                    let currentEntry = null;

                    for (let line of lines) {
                        line = line.trim();

                        // Skip title and empty lines
                        if (!line || line.startsWith("Anthology,")) continue;

                        // Check if this is a timecode line (supports both MM:SS and HH:MM:SS)
                        const timecodeMatch = line.match(
                            /^(\d{1,2}:\d{2}(?::\d{2})?)/
                        );

                        if (timecodeMatch) {
                            // Save previous entry if it exists
                            if (currentEntry) {
                                entries.push(currentEntry);
                            }

                            // Start new entry
                            currentEntry = {
                                timecode: timecodeMatch[1],
                                content: line
                                    .substring(timecodeMatch[0].length)
                                    .trim(),
                            };
                        } else if (currentEntry && line.startsWith("-")) {
                            // This is a continuation (like photo differences)
                            currentEntry.content += "\n" + line;
                        }
                    }

                    // Don't forget the last entry
                    if (currentEntry) {
                        entries.push(currentEntry);
                    }

                    return entries;
                }

                formatContent(text) {
                    // Convert markdown-like formatting to HTML
                    return text
                        .replace(/_([^_]+)_/g, "<em>$1</em>") // Italics
                        .replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>") // Bold
                        .replace(/\[edit\]/g, "<strong>[edit]</strong>")
                        .replace(/\n/g, "<br>");
                }
            }

            class TranscriptRenderer {
                constructor(container) {
                    this.container = container;
                    this.dvdContent = document.getElementById("dvd-content");
                    this.dplusContent =
                        document.getElementById("dplus-content");
                    this.arrowLayer = document.getElementById("arrow-layer");
                    this.parser = new TranscriptParser();
                }

                async loadFile(filename) {
                    const response = await fetch(filename);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${filename}`);
                    }
                    return await response.text();
                }

                renderEntry(entry, index, column) {
                    const div = document.createElement("div");
                    div.className = "entry";
                    div.dataset.index = index;
                    div.dataset.column = column;

                    const timecode = document.createElement("div");
                    timecode.className = "timecode";

                    // Optionally show index number for debugging
                    if (SHOW_INDICES) {
                        const indexBadge = document.createElement("span");
                        indexBadge.style.cssText =
                            "background: #555; padding: 2px 6px; border-radius: 3px; margin-right: 8px; font-size: 0.85em;";
                        indexBadge.textContent = `#${index}`;
                        timecode.appendChild(indexBadge);
                    }

                    const timecodeText = document.createTextNode(
                        entry.timecode
                    );
                    timecode.appendChild(timecodeText);

                    const content = document.createElement("div");
                    content.className = "content";
                    content.innerHTML = this.parser.formatContent(
                        entry.content
                    );

                    div.appendChild(timecode);
                    div.appendChild(content);

                    return div;
                }

                renderEntries(entries, container, column) {
                    entries.forEach((entry, index) => {
                        const entryDiv = this.renderEntry(entry, index, column);
                        container.appendChild(entryDiv);
                    });
                }

                alignAndDrawArrows(matches, dvdCount, dplusCount) {
                    // Clear existing spacers
                    document
                        .querySelectorAll(".spacer")
                        .forEach((el) => el.remove());

                    // Mark matched entries and collect all elements
                    const dvdElements = [];
                    const dplusElements = [];

                    for (let i = 0; i < dvdCount; i++) {
                        const el = this.dvdContent.querySelector(
                            `[data-index="${i}"]`
                        );
                        dvdElements.push(el);
                    }

                    for (let i = 0; i < dplusCount; i++) {
                        const el = this.dplusContent.querySelector(
                            `[data-index="${i}"]`
                        );
                        dplusElements.push(el);
                    }

                    matches.forEach((match) => {
                        if (dvdElements[match.dvd])
                            dvdElements[match.dvd].classList.add("matched");
                        if (dplusElements[match.dplus])
                            dplusElements[match.dplus].classList.add("matched");
                    });

                    // Filter out matches that represent extreme reordering
                    // Only use matches for alignment where both indices increase monotonically
                    const monotonic = [];
                    let lastDvd = -1;
                    let lastDplus = -1;

                    const sortedMatches = [...matches].sort(
                        (a, b) => a.dvd - b.dvd
                    );

                    sortedMatches.forEach((match) => {
                        // Only use this match for alignment if both indices are increasing
                        if (match.dvd > lastDvd && match.dplus > lastDplus) {
                            monotonic.push(match);
                            lastDvd = match.dvd;
                            lastDplus = match.dplus;
                        }
                    });

                    // Now further filter to avoid aligning isolated matches that create huge gaps
                    // Calculate "cost" for each potential alignment match
                    const alignmentMatches = [];
                    const diagnostics = [];

                    for (let i = 0; i < monotonic.length; i++) {
                        const current = monotonic[i];
                        const prev = monotonic[i - 1];
                        const next = monotonic[i + 1];

                        // Calculate gap sizes on both sides
                        const dvdGapBefore = prev
                            ? current.dvd - prev.dvd - 1
                            : current.dvd;
                        const dplusGapBefore = prev
                            ? current.dplus - prev.dplus - 1
                            : current.dplus;

                        const dvdGapAfter = next
                            ? next.dvd - current.dvd - 1
                            : dvdCount - current.dvd - 1;
                        const dplusGapAfter = next
                            ? next.dplus - current.dplus - 1
                            : dplusCount - current.dplus - 1;

                        // Calculate the "mismatch" - how different the gaps are
                        const mismatchBefore = Math.abs(
                            dvdGapBefore - dplusGapBefore
                        );
                        const mismatchAfter = Math.abs(
                            dvdGapAfter - dplusGapAfter
                        );
                        const totalMismatch = mismatchBefore + mismatchAfter;

                        // Calculate density - how many matches are nearby
                        const windowSize = 10;
                        let nearbyMatches = 0;
                        for (
                            let j = Math.max(0, i - windowSize);
                            j < Math.min(monotonic.length, i + windowSize);
                            j++
                        ) {
                            if (j !== i) nearbyMatches++;
                        }

                        // Skip this match if it creates significant mismatch
                        // Tighter thresholds to avoid aligning items that create large gaps
                        const isIsolated = nearbyMatches < 2;
                        const hasModerateMismatch = totalMismatch > 10;
                        const hasLargeMismatch = totalMismatch > 12;

                        const shouldSkip =
                            hasLargeMismatch ||
                            (isIsolated && hasModerateMismatch);

                        // Record diagnostics
                        diagnostics.push({
                            dvd: current.dvd,
                            dplus: current.dplus,
                            dvdGapBefore,
                            dplusGapBefore,
                            dvdGapAfter,
                            dplusGapAfter,
                            mismatchBefore,
                            mismatchAfter,
                            totalMismatch,
                            nearbyMatches,
                            isIsolated,
                            hasModerateMismatch,
                            hasLargeMismatch,
                            decision: shouldSkip ? "SKIP" : "ALIGN",
                        });

                        if (shouldSkip) {
                            // Skip this match for alignment (but still draw arrow)
                            continue;
                        }

                        alignmentMatches.push(current);
                    }

                    console.log(
                        `Total matches: ${matches.length}, Monotonic: ${monotonic.length}, Alignment matches: ${alignmentMatches.length}`
                    );

                    // Log diagnostics table
                    console.log("\n=== ALIGNMENT DIAGNOSTICS ===");
                    console.table(diagnostics);

                    // Find and highlight problematic alignments
                    const problematic = diagnostics
                        .filter(
                            (d) =>
                                d.decision === "ALIGN" && d.totalMismatch > 10
                        )
                        .sort((a, b) => b.totalMismatch - a.totalMismatch);

                    if (problematic.length > 0) {
                        console.warn(
                            "\nâš ï¸ POTENTIALLY PROBLEMATIC ALIGNMENTS (sorted by mismatch):"
                        );
                        console.table(problematic);
                    }

                    // Calculate total alignment cost
                    const totalCost = alignmentMatches.reduce(
                        (sum, match, i) => {
                            const diag = diagnostics.find(
                                (d) =>
                                    d.dvd === match.dvd &&
                                    d.dplus === match.dplus
                            );
                            return sum + (diag ? diag.totalMismatch : 0);
                        },
                        0
                    );

                    console.log(`\nðŸ“Š Total alignment cost: ${totalCost}`);

                    // Build set of matched indices (for all matches, not just alignment)
                    const dvdMatched = new Set(matches.map((m) => m.dvd));
                    const dplusMatched = new Set(matches.map((m) => m.dplus));

                    // Track the last processed indices
                    let lastDvdIdx = -1;
                    let lastDplusIdx = -1;

                    // Use only alignmentMatches for creating spacers
                    alignmentMatches.forEach((match, matchIdx) => {
                        // Calculate height of unmatched DVD items between last match and this match
                        let dvdHeight = 0;
                        for (let i = lastDvdIdx + 1; i < match.dvd; i++) {
                            if (dvdElements[i] && !dvdMatched.has(i)) {
                                dvdHeight += dvdElements[i].offsetHeight + 12; // Include margin
                            }
                        }

                        // Calculate height of unmatched Disney+ items between last match and this match
                        let dplusHeight = 0;
                        for (let i = lastDplusIdx + 1; i < match.dplus; i++) {
                            if (dplusElements[i] && !dplusMatched.has(i)) {
                                dplusHeight +=
                                    dplusElements[i].offsetHeight + 12; // Include margin
                            }
                        }

                        // Insert spacer on the side with less content
                        const heightDiff = Math.abs(dvdHeight - dplusHeight);
                        if (heightDiff > 10) {
                            // Only if difference is significant
                            const spacer = document.createElement("div");
                            spacer.className = "spacer";
                            spacer.style.height = heightDiff + "px";

                            if (dvdHeight < dplusHeight) {
                                // DVD side has less content, add spacer before this DVD match
                                const dvdEl = dvdElements[match.dvd];
                                if (dvdEl) {
                                    dvdEl.parentNode.insertBefore(
                                        spacer,
                                        dvdEl
                                    );
                                }
                            } else {
                                // Disney+ side has less content, add spacer before this Disney+ match
                                const dplusEl = dplusElements[match.dplus];
                                if (dplusEl) {
                                    dplusEl.parentNode.insertBefore(
                                        spacer,
                                        dplusEl
                                    );
                                }
                            }
                        }

                        lastDvdIdx = match.dvd;
                        lastDplusIdx = match.dplus;
                    });

                    // Fine-tune alignment by checking actual positions (only for alignment matches)
                    setTimeout(() => {
                        alignmentMatches.forEach((match) => {
                            const dvdEl = this.dvdContent.querySelector(
                                `[data-index="${match.dvd}"]`
                            );
                            const dplusEl = this.dplusContent.querySelector(
                                `[data-index="${match.dplus}"]`
                            );

                            if (dvdEl && dplusEl) {
                                const dvdRect = dvdEl.getBoundingClientRect();
                                const dplusRect =
                                    dplusEl.getBoundingClientRect();
                                const diff = dplusRect.top - dvdRect.top;

                                if (Math.abs(diff) > 10) {
                                    const spacer =
                                        document.createElement("div");
                                    spacer.className = "spacer";
                                    spacer.style.height = Math.abs(diff) + "px";

                                    if (diff > 0) {
                                        // Disney+ is lower, add spacer before DVD element
                                        dvdEl.parentNode.insertBefore(
                                            spacer,
                                            dvdEl
                                        );
                                    } else {
                                        // DVD is lower, add spacer before Disney+ element
                                        dplusEl.parentNode.insertBefore(
                                            spacer,
                                            dplusEl
                                        );
                                    }
                                }
                            }
                        });

                        // Draw arrows for ALL matches (including reordered ones)
                        setTimeout(() => {
                            this.drawArrows(matches);
                            // Setup interactions after arrows are drawn
                            this.setupInteractions(matches);
                        }, 100);
                    }, 50);
                }

                drawArrows(matches) {
                    // Clear existing arrows
                    this.arrowLayer.innerHTML = "";

                    const containerRect =
                        this.container.getBoundingClientRect();
                    const columnsEl = document.querySelector(".columns");
                    const columnsRect = columnsEl.getBoundingClientRect();

                    // Set SVG dimensions
                    this.arrowLayer.setAttribute("width", columnsRect.width);
                    this.arrowLayer.setAttribute("height", columnsRect.height);
                    this.arrowLayer.style.left =
                        columnsRect.left - containerRect.left + "px";
                    this.arrowLayer.style.top =
                        columnsRect.top - containerRect.top + "px";

                    matches.forEach((match) => {
                        const dvdEl = this.dvdContent.querySelector(
                            `[data-index="${match.dvd}"]`
                        );
                        const dplusEl = this.dplusContent.querySelector(
                            `[data-index="${match.dplus}"]`
                        );

                        if (!dvdEl || !dplusEl) return;

                        const dvdRect = dvdEl.getBoundingClientRect();
                        const dplusRect = dplusEl.getBoundingClientRect();

                        // Calculate positions relative to columns container
                        const x1 = dvdRect.right - columnsRect.left;
                        const y1 =
                            dvdRect.top - columnsRect.top + dvdRect.height / 2;
                        const x2 = dplusRect.left - columnsRect.left;
                        const y2 =
                            dplusRect.top -
                            columnsRect.top +
                            dplusRect.height / 2;

                        // Create curved path
                        const midX = (x1 + x2) / 2;
                        const path = document.createElementNS(
                            "http://www.w3.org/2000/svg",
                            "path"
                        );
                        const d = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
                        path.setAttribute("d", d);

                        // Color code by match type
                        const className =
                            match.matchType === "same"
                                ? "arrow-line strong-match"
                                : "arrow-line";
                        path.setAttribute("class", className);

                        // Store connection info for hover/click interactions
                        path.setAttribute("data-dvd", match.dvd);
                        path.setAttribute("data-dplus", match.dplus);

                        this.arrowLayer.appendChild(path);
                    });
                }

                setupInteractions(matches) {
                    const allEntries = document.querySelectorAll(".entry");
                    const allArrows =
                        this.arrowLayer.querySelectorAll(".arrow-line");

                    // Build lookup maps for which arrows connect to which entries
                    const dvdToArrows = {};
                    const dplusToArrows = {};

                    allArrows.forEach((arrow) => {
                        const dvdIdx = arrow.getAttribute("data-dvd");
                        const dplusIdx = arrow.getAttribute("data-dplus");

                        if (!dvdToArrows[dvdIdx]) dvdToArrows[dvdIdx] = [];
                        if (!dplusToArrows[dplusIdx])
                            dplusToArrows[dplusIdx] = [];

                        dvdToArrows[dvdIdx].push(arrow);
                        dplusToArrows[dplusIdx].push(arrow);
                    });

                    // Build lookup map for corresponding entries
                    const dvdToDplus = {};
                    const dplusToDvd = {};

                    matches.forEach((match) => {
                        if (!dvdToDplus[match.dvd]) dvdToDplus[match.dvd] = [];
                        if (!dplusToDvd[match.dplus])
                            dplusToDvd[match.dplus] = [];

                        dvdToDplus[match.dvd].push(match.dplus);
                        dplusToDvd[match.dplus].push(match.dvd);
                    });

                    // Add hover and click listeners to all entries
                    allEntries.forEach((entry) => {
                        const index = entry.dataset.index;
                        const column = entry.dataset.column;

                        // Hover to highlight arrows
                        entry.addEventListener("mouseenter", () => {
                            const relevantArrows =
                                column === "dvd"
                                    ? dvdToArrows[index]
                                    : dplusToArrows[index];

                            if (relevantArrows && relevantArrows.length > 0) {
                                // Dim all arrows
                                allArrows.forEach((arrow) =>
                                    arrow.classList.add("dimmed")
                                );
                                // Highlight relevant arrows
                                relevantArrows.forEach((arrow) => {
                                    arrow.classList.remove("dimmed");
                                    arrow.classList.add("highlighted");
                                });
                            }
                        });

                        entry.addEventListener("mouseleave", () => {
                            // Remove all highlighting
                            allArrows.forEach((arrow) => {
                                arrow.classList.remove("dimmed");
                                arrow.classList.remove("highlighted");
                            });
                        });

                        // Click to scroll to corresponding entry
                        entry.addEventListener("click", () => {
                            const correspondingIndices =
                                column === "dvd"
                                    ? dvdToDplus[index]
                                    : dplusToDvd[index];

                            if (
                                correspondingIndices &&
                                correspondingIndices.length > 0
                            ) {
                                // Scroll to the first corresponding entry
                                const targetIndex = correspondingIndices[0];
                                const targetColumn =
                                    column === "dvd" ? "dplus" : "dvd";
                                const targetEl = document.querySelector(
                                    `[data-index="${targetIndex}"][data-column="${targetColumn}"]`
                                );

                                if (targetEl) {
                                    // Remove previous highlight
                                    document
                                        .querySelectorAll(".highlight-target")
                                        .forEach((el) => {
                                            el.classList.remove(
                                                "highlight-target"
                                            );
                                        });

                                    // Add highlight to target
                                    targetEl.classList.add("highlight-target");

                                    // Scroll to center
                                    targetEl.scrollIntoView({
                                        behavior: "smooth",
                                        block: "center",
                                    });

                                    // Remove highlight after 2 seconds
                                    setTimeout(() => {
                                        targetEl.classList.remove(
                                            "highlight-target"
                                        );
                                    }, 2000);
                                }
                            }
                        });
                    });
                }

                async render() {
                    try {
                        // Load both transcript files and mapping
                        const [dvdText, dplusText, mappingResponse] =
                            await Promise.all([
                                this.loadFile("1-dvd.md"),
                                this.loadFile("1-dplus.md"),
                                fetch("mapping.json"),
                            ]);

                        const mappingData = await mappingResponse.json();
                        const matches = mappingData.mappings;

                        // Parse entries
                        const dvdEntries = this.parser.parse(dvdText);
                        const dplusEntries = this.parser.parse(dplusText);

                        console.log(
                            `DVD entries: ${dvdEntries.length}, Disney+ entries: ${dplusEntries.length}`
                        );
                        console.log(
                            `Loaded ${matches.length} matches from mapping file`
                        );

                        // Render entries
                        this.renderEntries(dvdEntries, this.dvdContent, "dvd");
                        this.renderEntries(
                            dplusEntries,
                            this.dplusContent,
                            "dplus"
                        );

                        // Hide loading, show content
                        document.getElementById("loading").style.display =
                            "none";
                        this.container.style.display = "block";

                        // Align and draw arrows after render
                        // (setupInteractions is called automatically after arrows are drawn)
                        setTimeout(() => {
                            this.alignAndDrawArrows(
                                matches,
                                dvdEntries.length,
                                dplusEntries.length
                            );
                        }, 100);

                        // Redraw arrows on window resize
                        let resizeTimeout;
                        window.addEventListener("resize", () => {
                            clearTimeout(resizeTimeout);
                            resizeTimeout = setTimeout(() => {
                                this.drawArrows(matches);
                                this.setupInteractions(matches);
                            }, 200);
                        });
                    } catch (error) {
                        document.getElementById(
                            "loading"
                        ).innerHTML = `<div class="error">Error: ${error.message}</div>`;
                        console.error(error);
                    }
                }
            }

            // Initialize when page loads
            window.addEventListener("DOMContentLoaded", () => {
                // Add debug indicator to title if enabled
                if (SHOW_INDICES) {
                    const h1 = document.querySelector("h1");
                    const indicator = document.createElement("span");
                    indicator.className = "debug-indicator";
                    indicator.textContent = "DEBUG MODE";
                    h1.appendChild(indicator);
                }

                const renderer = new TranscriptRenderer(
                    document.getElementById("container")
                );
                renderer.render();
            });
        </script>
    </body>
</html>

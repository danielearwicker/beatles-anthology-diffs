<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Beatles Anthology - DVD vs Disney+ Comparison</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                    Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                background: #1a1a1a;
                color: #e0e0e0;
                padding: 20px;
                line-height: 1.6;
            }

            h1 {
                text-align: center;
                margin-bottom: 15px;
                color: #fff;
                font-size: 2em;
            }

            a {
                color: #4caf50;
            }

            .episode-nav {
                text-align: center;
                margin-bottom: 30px;
                display: flex;
                justify-content: center;
                gap: 15px;
                flex-wrap: wrap;
            }

            .episode-link {
                display: inline-block;
                padding: 8px 16px;
                background: #2a2a2a;
                color: #e0e0e0;
                text-decoration: none;
                border-radius: 6px;
                border: 2px solid #555;
                transition: all 0.2s;
                font-weight: 500;
            }

            .episode-link:hover {
                background: #333;
                border-color: #4caf50;
                transform: translateY(-2px);
            }

            .episode-link.active {
                background: #4caf50;
                border-color: #4caf50;
                color: #1a1a1a;
                font-weight: bold;
            }

            p {
                margin: 10px 0;
            }

            .debug-indicator {
                display: inline-block;
                background: #ff6b6b;
                color: white;
                padding: 4px 12px;
                border-radius: 4px;
                font-size: 0.5em;
                margin-left: 15px;
                vertical-align: middle;
            }

            .container {
                max-width: 1800px;
                margin: 0 auto;
                position: relative;
            }

            .columns {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 100px;
                position: relative;
            }

            .column {
                position: relative;
            }

            .column-header {
                position: sticky;
                top: 0;
                background: #1a1a1a;
                padding: 15px 20px;
                margin-bottom: 20px;
                border-bottom: 2px solid #4caf50;
                z-index: 10;
                font-weight: bold;
                font-size: 1.2em;
            }

            .dvd-header {
                border-bottom-color: #2196f3;
            }

            .dplus-header {
                border-bottom-color: #ff9800;
            }

            .entry {
                background: #2a2a2a;
                padding: 15px;
                margin-bottom: 12px;
                border-radius: 6px;
                border-left: 4px solid #555;
                transition: all 0.2s;
            }

            .entry:hover {
                background: #333;
                transform: translateX(2px);
            }

            .dvd .entry {
                border-left-color: #2196f3;
            }

            .dplus .entry {
                border-left-color: #ff9800;
            }

            .entry.matched {
                border-left-width: 6px;
                cursor: pointer;
            }

            .entry.dropped {
                background: rgba(139, 0, 0, 0.15);
            }

            .entry.dropped:hover {
                background: rgba(139, 0, 0, 0.25);
            }

            .entry.added {
                background: rgba(0, 100, 0, 0.15);
            }

            .entry.added:hover {
                background: rgba(0, 100, 0, 0.25);
            }

            .timecode {
                font-weight: bold;
                color: #4caf50;
                font-family: "Courier New", monospace;
                margin-bottom: 8px;
                font-size: 0.95em;
            }

            .content {
                color: #e0e0e0;
            }

            .content em {
                color: #ffd700;
                font-style: italic;
            }

            .content strong {
                color: #ff6b6b;
                font-weight: bold;
            }

            .content a {
                color: #4caf50;
                text-decoration: underline;
                cursor: pointer;
                transition: color 0.2s;
            }

            .content a:hover {
                color: #66bb6a;
            }

            .spacer {
                height: 0;
                transition: height 0.3s;
            }

            #arrow-layer {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 1;
            }

            .arrow-line {
                fill: none;
                stroke: #4caf50;
                stroke-width: 2;
                opacity: 0.6;
                transition: opacity 0.2s;
            }

            .arrow-line.strong-match {
                stroke: #ffd700;
                stroke-width: 3;
                opacity: 0.8;
            }

            .arrow-line.dimmed {
                opacity: 0.1 !important;
            }

            .arrow-line.highlighted {
                opacity: 1 !important;
                stroke-width: 4 !important;
            }

            .entry.highlight-target {
                background: #3a3a3a;
                box-shadow: 0 0 20px rgba(76, 175, 80, 0.4);
            }

            .loading {
                text-align: center;
                padding: 50px;
                font-size: 1.2em;
                color: #888;
            }

            .error {
                background: #d32f2f;
                color: white;
                padding: 20px;
                border-radius: 6px;
                margin: 20px;
            }

            @media (max-width: 1200px) {
                .columns {
                    gap: 40px;
                }
            }
        </style>
    </head>
    <body>
        <h1>Beatles Anthology - DVD vs Disney+ Comparison</h1>
        <nav class="episode-nav" id="episode-nav">
            <a href="#" class="episode-link" data-episode="1">Episode 1</a>
            <a href="#2" class="episode-link" data-episode="2">Episode 2</a>
            <a href="#3" class="episode-link" data-episode="3">Episode 3</a>
            <a href="#4" class="episode-link" data-episode="4">Episode 4</a>
        </nav>
        <p>
            Are you wondering how has the Beatles Anthology documentary changed
            between the 2003 DVD version and the 2025 Disney+ version? Here is
            an attempt to answer that question.
        </p>
        <p>
            This is not a complete transcript. It includes items removed from
            the original DVD version (dark red items on the left) or added to
            the Disney+ version (dark green items on the right), and also some
            items reordered or modified which are connected by links. You can
            click on an item to follow the link to see where it appears in the
            other version.
        </p>
        <p>
            There are many changes that apply across the whole series,
            especially the widespread use of AI to clean up footage and emulate
            detail, and the elimination of fades between clips.
        </p>
        <p>
            <a href="https://github.com/danielearwicker/beatles-anthology"
                >Source on Github</a
            >
        </p>
        <div class="loading" id="loading">Loading transcripts...</div>
        <div class="container" id="container" style="display: none">
            <svg id="arrow-layer"></svg>
            <div class="columns">
                <div class="column dvd">
                    <div class="column-header dvd-header">2003 DVD Version</div>
                    <div id="dvd-content"></div>
                </div>
                <div class="column dplus">
                    <div class="column-header dplus-header">
                        2025 Disney+ Version
                    </div>
                    <div id="dplus-content"></div>
                </div>
            </div>
        </div>

        <script>
            // DEBUG: Set to true to show index numbers next to entries
            const SHOW_INDICES = false;

            // Parse episode and item from URL hash
            // Format: #dvd54 (episode 1, backward compat), #2 (episode 2), or #3&dvd54 (episode 3, item dvd54)
            function parseHash(hash) {
                if (!hash) return { episode: 1, itemId: null };

                const cleaned = hash.startsWith("#") ? hash.substring(1) : hash;

                if (cleaned.includes("&")) {
                    // Format: #3&dvd54
                    const [episodeStr, itemId] = cleaned.split("&");
                    return {
                        episode: parseInt(episodeStr) || 1,
                        itemId: itemId || null,
                    };
                } else if (/^\d+$/.test(cleaned)) {
                    // Just a number: treat as episode number (e.g., #2)
                    return {
                        episode: parseInt(cleaned) || 1,
                        itemId: null,
                    };
                } else {
                    // Backward compat: no ampersand and not just a number means episode 1 with itemId
                    return {
                        episode: 1,
                        itemId: cleaned || null,
                    };
                }
            }

            // Format episode and item into URL hash
            function formatHash(episode, itemId) {
                if (episode === 1) {
                    // Episode 1: use backward-compatible format (no episode number)
                    return itemId ? `#${itemId}` : "";
                } else {
                    // Other episodes: include episode number
                    return itemId ? `#${episode}&${itemId}` : `#${episode}`;
                }
            }

            class TranscriptParser {
                parse(text) {
                    const lines = text.split("\n");
                    const entries = [];
                    let currentEntry = null;

                    for (let line of lines) {
                        line = line.trim();

                        // Skip title and empty lines
                        if (!line || line.startsWith("Anthology,")) continue;

                        // Check if this is a timecode line (supports both MM:SS and HH:MM:SS)
                        const timecodeMatch = line.match(
                            /^(\d{1,2}:\d{2}(?::\d{2})?)/
                        );

                        if (timecodeMatch) {
                            // Save previous entry if it exists
                            if (currentEntry) {
                                entries.push(currentEntry);
                            }

                            // Start new entry
                            currentEntry = {
                                timecode: timecodeMatch[1],
                                content: line
                                    .substring(timecodeMatch[0].length)
                                    .trim(),
                            };
                        } else if (currentEntry && line.startsWith("-")) {
                            // This is a continuation (like photo differences)
                            currentEntry.content += "\n" + line;
                        }
                    }

                    // Don't forget the last entry
                    if (currentEntry) {
                        entries.push(currentEntry);
                    }

                    return entries;
                }

                formatContent(text) {
                    // Convert markdown-like formatting to HTML
                    return text
                        .replace(
                            /\[([^\]]+)\]\(#([^)]+)\)/g,
                            '<a href="#$2">$1</a>'
                        ) // Links
                        .replace(/_([^_]+)_/g, "<em>$1</em>") // Italics
                        .replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>") // Bold
                        .replace(/\[edit\]/g, "<strong>[edit]</strong>")
                        .replace(/\n/g, "<br>");
                }
            }

            class TranscriptRenderer {
                constructor(container, episode = 1) {
                    this.container = container;
                    this.episode = episode;
                    this.dvdContent = document.getElementById("dvd-content");
                    this.dplusContent =
                        document.getElementById("dplus-content");
                    this.arrowLayer = document.getElementById("arrow-layer");
                    this.parser = new TranscriptParser();
                }

                async loadFile(filename) {
                    const response = await fetch(filename);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${filename}`);
                    }
                    return await response.text();
                }

                renderEntry(entry, index, column) {
                    const div = document.createElement("div");
                    div.className = "entry";
                    div.dataset.index = index;
                    div.dataset.column = column;
                    div.id = `${column}${index}`; // Add ID for deep linking

                    const timecode = document.createElement("div");
                    timecode.className = "timecode";

                    // Optionally show index number for debugging
                    if (SHOW_INDICES) {
                        const indexBadge = document.createElement("span");
                        indexBadge.style.cssText =
                            "background: #555; padding: 2px 6px; border-radius: 3px; margin-right: 8px; font-size: 0.85em;";
                        indexBadge.textContent = `#${index}`;
                        timecode.appendChild(indexBadge);
                    }

                    const timecodeText = document.createTextNode(
                        entry.timecode
                    );
                    timecode.appendChild(timecodeText);

                    const content = document.createElement("div");
                    content.className = "content";
                    content.innerHTML = this.parser.formatContent(
                        entry.content
                    );

                    div.appendChild(timecode);
                    div.appendChild(content);

                    return div;
                }

                renderEntries(entries, container, column) {
                    entries.forEach((entry, index) => {
                        const entryDiv = this.renderEntry(entry, index, column);
                        container.appendChild(entryDiv);
                    });
                }

                alignAndDrawArrows(matches, dvdCount, dplusCount) {
                    // Clear existing spacers
                    document
                        .querySelectorAll(".spacer")
                        .forEach((el) => el.remove());

                    // Mark matched entries and collect all elements
                    const dvdElements = [];
                    const dplusElements = [];

                    for (let i = 0; i < dvdCount; i++) {
                        const el = this.dvdContent.querySelector(
                            `[data-index="${i}"]`
                        );
                        dvdElements.push(el);
                    }

                    for (let i = 0; i < dplusCount; i++) {
                        const el = this.dplusContent.querySelector(
                            `[data-index="${i}"]`
                        );
                        dplusElements.push(el);
                    }

                    // Build sets of matched indices
                    const dvdMatchedSet = new Set(matches.map((m) => m.dvd));
                    const dplusMatchedSet = new Set(
                        matches.map((m) => m.dplus)
                    );

                    // Mark matched entries
                    matches.forEach((match) => {
                        if (dvdElements[match.dvd])
                            dvdElements[match.dvd].classList.add("matched");
                        if (dplusElements[match.dplus])
                            dplusElements[match.dplus].classList.add("matched");
                    });

                    // Mark dropped DVD entries (no mapping to Disney+)
                    for (let i = 0; i < dvdCount; i++) {
                        if (!dvdMatchedSet.has(i) && dvdElements[i]) {
                            dvdElements[i].classList.add("dropped");
                        }
                    }

                    // Mark added Disney+ entries (no mapping from DVD)
                    for (let i = 0; i < dplusCount; i++) {
                        if (!dplusMatchedSet.has(i) && dplusElements[i]) {
                            dplusElements[i].classList.add("added");
                        }
                    }

                    // Filter out matches that represent extreme reordering
                    // Only use matches for alignment where both indices increase monotonically
                    // EXCEPT for forced alignments which are always included
                    const monotonic = [];
                    let lastDvd = -1;
                    let lastDplus = -1;

                    const sortedMatches = [...matches].sort(
                        (a, b) => a.dvd - b.dvd
                    );

                    sortedMatches.forEach((match) => {
                        // Always include forced alignments, or matches where both indices are increasing
                        const isForced = match.aligned === true;
                        const isMonotonic =
                            match.dvd > lastDvd && match.dplus > lastDplus;

                        if (isForced || isMonotonic) {
                            monotonic.push(match);
                            if (isMonotonic) {
                                lastDvd = match.dvd;
                                lastDplus = match.dplus;
                            }
                        }
                    });

                    // Now further filter to avoid aligning isolated matches that create huge gaps
                    // Calculate "cost" for each potential alignment match
                    const alignmentMatches = [];
                    const diagnostics = [];

                    for (let i = 0; i < monotonic.length; i++) {
                        const current = monotonic[i];
                        const prev = monotonic[i - 1];
                        const next = monotonic[i + 1];

                        // Calculate gap sizes on both sides
                        const dvdGapBefore = prev
                            ? current.dvd - prev.dvd - 1
                            : current.dvd;
                        const dplusGapBefore = prev
                            ? current.dplus - prev.dplus - 1
                            : current.dplus;

                        const dvdGapAfter = next
                            ? next.dvd - current.dvd - 1
                            : dvdCount - current.dvd - 1;
                        const dplusGapAfter = next
                            ? next.dplus - current.dplus - 1
                            : dplusCount - current.dplus - 1;

                        // Calculate the "mismatch" - how different the gaps are
                        const mismatchBefore = Math.abs(
                            dvdGapBefore - dplusGapBefore
                        );
                        const mismatchAfter = Math.abs(
                            dvdGapAfter - dplusGapAfter
                        );
                        const totalMismatch = mismatchBefore + mismatchAfter;

                        // Calculate density - how many matches are nearby
                        const windowSize = 10;
                        let nearbyMatches = 0;
                        for (
                            let j = Math.max(0, i - windowSize);
                            j < Math.min(monotonic.length, i + windowSize);
                            j++
                        ) {
                            if (j !== i) nearbyMatches++;
                        }

                        // Skip this match if it creates significant mismatch
                        // Tighter thresholds to avoid aligning items that create large gaps
                        const isIsolated = nearbyMatches < 2;
                        const hasModerateMismatch = totalMismatch > 10;
                        const hasLargeMismatch = totalMismatch > 12;

                        // Check if this is a forced alignment anchor
                        const isForced = current.aligned === true;

                        const shouldSkip =
                            !isForced &&
                            (hasLargeMismatch ||
                                (isIsolated && hasModerateMismatch));

                        // Record diagnostics
                        diagnostics.push({
                            dvd: current.dvd,
                            dplus: current.dplus,
                            dvdGapBefore,
                            dplusGapBefore,
                            dvdGapAfter,
                            dplusGapAfter,
                            mismatchBefore,
                            mismatchAfter,
                            totalMismatch,
                            nearbyMatches,
                            isIsolated,
                            hasModerateMismatch,
                            hasLargeMismatch,
                            isForced,
                            decision: shouldSkip
                                ? "SKIP"
                                : isForced
                                ? "FORCED"
                                : "ALIGN",
                        });

                        if (shouldSkip) {
                            // Skip this match for alignment (but still draw arrow)
                            continue;
                        }

                        alignmentMatches.push(current);
                    }

                    console.log(
                        `Total matches: ${matches.length}, Monotonic: ${monotonic.length}, Alignment matches: ${alignmentMatches.length}`
                    );

                    // Log diagnostics table
                    console.log("\n=== ALIGNMENT DIAGNOSTICS ===");
                    console.table(diagnostics);

                    // Highlight forced alignments
                    const forced = diagnostics.filter((d) => d.isForced);
                    if (forced.length > 0) {
                        console.log("\nðŸ”’ FORCED ALIGNMENT ANCHORS:");
                        console.table(forced);
                    }

                    // Find and highlight problematic alignments
                    const problematic = diagnostics
                        .filter(
                            (d) =>
                                d.decision === "ALIGN" && d.totalMismatch > 10
                        )
                        .sort((a, b) => b.totalMismatch - a.totalMismatch);

                    if (problematic.length > 0) {
                        console.warn(
                            "\nâš ï¸ POTENTIALLY PROBLEMATIC ALIGNMENTS (sorted by mismatch):"
                        );
                        console.table(problematic);
                    }

                    // Calculate total alignment cost
                    const totalCost = alignmentMatches.reduce(
                        (sum, match, i) => {
                            const diag = diagnostics.find(
                                (d) =>
                                    d.dvd === match.dvd &&
                                    d.dplus === match.dplus
                            );
                            return sum + (diag ? diag.totalMismatch : 0);
                        },
                        0
                    );

                    console.log(`\nðŸ“Š Total alignment cost: ${totalCost}`);

                    // Build set of matched indices (for all matches, not just alignment)
                    const dvdMatched = new Set(matches.map((m) => m.dvd));
                    const dplusMatched = new Set(matches.map((m) => m.dplus));

                    // Sort alignmentMatches to ensure we process them in a sensible order
                    // This prevents forced alignments from breaking the sequential processing
                    const sortedAlignments = [...alignmentMatches].sort(
                        (a, b) => {
                            // Primary sort by DVD index
                            if (a.dvd !== b.dvd) return a.dvd - b.dvd;
                            // Secondary sort by Disney+ index
                            return a.dplus - b.dplus;
                        }
                    );

                    // Track the last processed indices
                    let lastDvdIdx = -1;
                    let lastDplusIdx = -1;

                    // Use only sortedAlignments for creating spacers
                    sortedAlignments.forEach((match, matchIdx) => {
                        // Skip if this alignment would go backwards (only possible with forced alignments)
                        if (
                            match.dvd <= lastDvdIdx ||
                            match.dplus <= lastDplusIdx
                        ) {
                            console.warn(
                                `âš ï¸ Skipping out-of-order forced alignment: DVD ${match.dvd} â†’ Disney+ ${match.dplus}`
                            );
                            return;
                        }
                        // Calculate height of ALL items between last alignment match and this one
                        // (This includes matched items that were skipped for alignment)
                        let dvdHeight = 0;
                        for (let i = lastDvdIdx + 1; i < match.dvd; i++) {
                            if (dvdElements[i]) {
                                dvdHeight += dvdElements[i].offsetHeight + 12; // Include margin
                            }
                        }

                        // Calculate height of ALL Disney+ items between last alignment match and this one
                        let dplusHeight = 0;
                        for (let i = lastDplusIdx + 1; i < match.dplus; i++) {
                            if (dplusElements[i]) {
                                dplusHeight +=
                                    dplusElements[i].offsetHeight + 12; // Include margin
                            }
                        }

                        // Insert spacer on the side with less content
                        const heightDiff = Math.abs(dvdHeight - dplusHeight);
                        if (heightDiff > 10) {
                            // Only if difference is significant
                            const spacer = document.createElement("div");
                            spacer.className = "spacer";
                            spacer.style.height = heightDiff + "px";

                            if (dvdHeight < dplusHeight) {
                                // DVD side has less content, add spacer before this DVD match
                                const dvdEl = dvdElements[match.dvd];
                                if (dvdEl) {
                                    dvdEl.parentNode.insertBefore(
                                        spacer,
                                        dvdEl
                                    );
                                }
                            } else {
                                // Disney+ side has less content, add spacer before this Disney+ match
                                const dplusEl = dplusElements[match.dplus];
                                if (dplusEl) {
                                    dplusEl.parentNode.insertBefore(
                                        spacer,
                                        dplusEl
                                    );
                                }
                            }
                        }

                        lastDvdIdx = match.dvd;
                        lastDplusIdx = match.dplus;
                    });

                    // Fine-tune alignment by checking actual positions (only for alignment matches)
                    setTimeout(() => {
                        alignmentMatches.forEach((match) => {
                            const dvdEl = this.dvdContent.querySelector(
                                `[data-index="${match.dvd}"]`
                            );
                            const dplusEl = this.dplusContent.querySelector(
                                `[data-index="${match.dplus}"]`
                            );

                            if (dvdEl && dplusEl) {
                                const dvdRect = dvdEl.getBoundingClientRect();
                                const dplusRect =
                                    dplusEl.getBoundingClientRect();
                                const diff = dplusRect.top - dvdRect.top;

                                if (Math.abs(diff) > 10) {
                                    const spacer =
                                        document.createElement("div");
                                    spacer.className = "spacer";
                                    spacer.style.height = Math.abs(diff) + "px";

                                    if (diff > 0) {
                                        // Disney+ is lower, add spacer before DVD element
                                        dvdEl.parentNode.insertBefore(
                                            spacer,
                                            dvdEl
                                        );
                                    } else {
                                        // DVD is lower, add spacer before Disney+ element
                                        dplusEl.parentNode.insertBefore(
                                            spacer,
                                            dplusEl
                                        );
                                    }
                                }
                            }
                        });

                        // Draw arrows for ALL matches (including reordered ones)
                        setTimeout(() => {
                            this.drawArrows(matches);
                            // Setup interactions after arrows are drawn
                            this.setupInteractions(matches);
                        }, 100);
                    }, 50);
                }

                drawArrows(matches) {
                    // Clear existing arrows
                    this.arrowLayer.innerHTML = "";

                    const containerRect =
                        this.container.getBoundingClientRect();
                    const columnsEl = document.querySelector(".columns");
                    const columnsRect = columnsEl.getBoundingClientRect();

                    // Set SVG dimensions
                    this.arrowLayer.setAttribute("width", columnsRect.width);
                    this.arrowLayer.setAttribute("height", columnsRect.height);
                    this.arrowLayer.style.left =
                        columnsRect.left - containerRect.left + "px";
                    this.arrowLayer.style.top =
                        columnsRect.top - containerRect.top + "px";

                    matches.forEach((match) => {
                        const dvdEl = this.dvdContent.querySelector(
                            `[data-index="${match.dvd}"]`
                        );
                        const dplusEl = this.dplusContent.querySelector(
                            `[data-index="${match.dplus}"]`
                        );

                        if (!dvdEl || !dplusEl) return;

                        const dvdRect = dvdEl.getBoundingClientRect();
                        const dplusRect = dplusEl.getBoundingClientRect();

                        // Calculate positions relative to columns container
                        const x1 = dvdRect.right - columnsRect.left;
                        const y1 =
                            dvdRect.top - columnsRect.top + dvdRect.height / 2;
                        const x2 = dplusRect.left - columnsRect.left;
                        const y2 =
                            dplusRect.top -
                            columnsRect.top +
                            dplusRect.height / 2;

                        // Create curved path
                        const midX = (x1 + x2) / 2;
                        const path = document.createElementNS(
                            "http://www.w3.org/2000/svg",
                            "path"
                        );
                        const d = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
                        path.setAttribute("d", d);

                        // Color code by match type
                        const className =
                            match.matchType === "same"
                                ? "arrow-line strong-match"
                                : "arrow-line";
                        path.setAttribute("class", className);

                        // Store connection info for hover/click interactions
                        path.setAttribute("data-dvd", match.dvd);
                        path.setAttribute("data-dplus", match.dplus);

                        this.arrowLayer.appendChild(path);
                    });
                }

                setupInteractions(matches) {
                    const allEntries = document.querySelectorAll(".entry");
                    const allArrows =
                        this.arrowLayer.querySelectorAll(".arrow-line");

                    // Build lookup maps for which arrows connect to which entries
                    const dvdToArrows = {};
                    const dplusToArrows = {};

                    allArrows.forEach((arrow) => {
                        const dvdIdx = arrow.getAttribute("data-dvd");
                        const dplusIdx = arrow.getAttribute("data-dplus");

                        if (!dvdToArrows[dvdIdx]) dvdToArrows[dvdIdx] = [];
                        if (!dplusToArrows[dplusIdx])
                            dplusToArrows[dplusIdx] = [];

                        dvdToArrows[dvdIdx].push(arrow);
                        dplusToArrows[dplusIdx].push(arrow);
                    });

                    // Build lookup map for corresponding entries
                    const dvdToDplus = {};
                    const dplusToDvd = {};

                    matches.forEach((match) => {
                        if (!dvdToDplus[match.dvd]) dvdToDplus[match.dvd] = [];
                        if (!dplusToDvd[match.dplus])
                            dplusToDvd[match.dplus] = [];

                        dvdToDplus[match.dvd].push(match.dplus);
                        dplusToDvd[match.dplus].push(match.dvd);
                    });

                    // Add hover and click listeners to all entries
                    allEntries.forEach((entry) => {
                        const index = entry.dataset.index;
                        const column = entry.dataset.column;

                        // Hover to highlight arrows
                        entry.addEventListener("mouseenter", () => {
                            const relevantArrows =
                                column === "dvd"
                                    ? dvdToArrows[index]
                                    : dplusToArrows[index];

                            if (relevantArrows && relevantArrows.length > 0) {
                                // Dim all arrows
                                allArrows.forEach((arrow) =>
                                    arrow.classList.add("dimmed")
                                );
                                // Highlight relevant arrows
                                relevantArrows.forEach((arrow) => {
                                    arrow.classList.remove("dimmed");
                                    arrow.classList.add("highlighted");
                                });
                            }
                        });

                        entry.addEventListener("mouseleave", () => {
                            // Remove all highlighting
                            allArrows.forEach((arrow) => {
                                arrow.classList.remove("dimmed");
                                arrow.classList.remove("highlighted");
                            });
                        });

                        // Click to scroll to corresponding entry (or self if unmatched)
                        entry.addEventListener("click", (e) => {
                            // Don't interfere with links inside the entry
                            if (
                                e.target.tagName === "A" ||
                                e.target.closest("a")
                            ) {
                                return;
                            }

                            const correspondingIndices =
                                column === "dvd"
                                    ? dvdToDplus[index]
                                    : dplusToDvd[index];

                            if (
                                correspondingIndices &&
                                correspondingIndices.length > 0
                            ) {
                                // Has a match - scroll to the first corresponding entry
                                const targetIndex = correspondingIndices[0];
                                const targetColumn =
                                    column === "dvd" ? "dplus" : "dvd";
                                const targetEl = document.querySelector(
                                    `[data-index="${targetIndex}"][data-column="${targetColumn}"]`
                                );

                                if (targetEl) {
                                    // Remove previous highlight
                                    document
                                        .querySelectorAll(".highlight-target")
                                        .forEach((el) => {
                                            el.classList.remove(
                                                "highlight-target"
                                            );
                                        });

                                    // Add highlight to target
                                    targetEl.classList.add("highlight-target");

                                    // Update URL hash for deep linking
                                    window.history.replaceState(
                                        null,
                                        null,
                                        formatHash(this.episode, targetEl.id)
                                    );

                                    // Scroll to center
                                    targetEl.scrollIntoView({
                                        behavior: "smooth",
                                        block: "center",
                                    });

                                    // Remove highlight after 2 seconds
                                    setTimeout(() => {
                                        targetEl.classList.remove(
                                            "highlight-target"
                                        );
                                    }, 2000);
                                }
                            } else {
                                // No match - just update hash to this item
                                window.history.replaceState(
                                    null,
                                    null,
                                    formatHash(this.episode, entry.id)
                                );
                            }
                        });
                    });

                    // Handle clicks on links within entry content
                    document.querySelectorAll(".content a").forEach((link) => {
                        link.addEventListener("click", (e) => {
                            e.preventDefault();
                            const hash = link.getAttribute("href");

                            if (hash && hash.startsWith("#")) {
                                const { episode: targetEpisode, itemId } =
                                    parseHash(hash);

                                if (targetEpisode !== this.episode) {
                                    // Different episode - reload page with new episode
                                    window.location.hash = hash.substring(1); // Remove leading #
                                    window.location.reload();
                                } else if (itemId) {
                                    // Same episode - scroll to target
                                    const targetEl =
                                        document.getElementById(itemId);
                                    if (targetEl) {
                                        targetEl.classList.add(
                                            "highlight-target"
                                        );
                                        targetEl.scrollIntoView({
                                            behavior: "smooth",
                                            block: "center",
                                        });
                                        // Update URL hash
                                        window.history.replaceState(
                                            null,
                                            null,
                                            hash
                                        );
                                        setTimeout(() => {
                                            targetEl.classList.remove(
                                                "highlight-target"
                                            );
                                        }, 2000);
                                    }
                                }
                            }
                        });
                    });
                }

                async render() {
                    try {
                        // Load both transcript files and mapping for this episode
                        const [dvdText, dplusText, mappingResponse] =
                            await Promise.all([
                                this.loadFile(`${this.episode}-dvd.md`),
                                this.loadFile(`${this.episode}-dplus.md`),
                                fetch(`${this.episode}-mapping.json`),
                            ]);

                        const mappingData = await mappingResponse.json();
                        const matches = mappingData.mappings;

                        console.log(`Loading Episode ${this.episode}`);

                        // Parse entries
                        const dvdEntries = this.parser.parse(dvdText);
                        const dplusEntries = this.parser.parse(dplusText);

                        console.log(
                            `DVD entries: ${dvdEntries.length}, Disney+ entries: ${dplusEntries.length}`
                        );
                        console.log(
                            `Loaded ${matches.length} matches from mapping file`
                        );

                        // Render entries
                        this.renderEntries(dvdEntries, this.dvdContent, "dvd");
                        this.renderEntries(
                            dplusEntries,
                            this.dplusContent,
                            "dplus"
                        );

                        // Hide loading, show content
                        document.getElementById("loading").style.display =
                            "none";
                        this.container.style.display = "block";

                        // Align and draw arrows after render
                        // (setupInteractions is called automatically after arrows are drawn)
                        setTimeout(() => {
                            this.alignAndDrawArrows(
                                matches,
                                dvdEntries.length,
                                dplusEntries.length
                            );

                            // Handle deep linking from URL hash
                            setTimeout(() => {
                                if (window.location.hash) {
                                    const { itemId } = parseHash(
                                        window.location.hash
                                    );
                                    if (itemId) {
                                        const targetEl =
                                            document.getElementById(itemId);
                                        if (targetEl) {
                                            targetEl.classList.add(
                                                "highlight-target"
                                            );
                                            targetEl.scrollIntoView({
                                                behavior: "smooth",
                                                block: "center",
                                            });
                                            setTimeout(() => {
                                                targetEl.classList.remove(
                                                    "highlight-target"
                                                );
                                            }, 3000);
                                        }
                                    }
                                }
                            }, 500);
                        }, 100);

                        // Redraw arrows on window resize
                        let resizeTimeout;
                        window.addEventListener("resize", () => {
                            clearTimeout(resizeTimeout);
                            resizeTimeout = setTimeout(() => {
                                this.drawArrows(matches);
                                this.setupInteractions(matches);
                            }, 200);
                        });
                    } catch (error) {
                        document.getElementById(
                            "loading"
                        ).innerHTML = `<div class="error">Error: ${error.message}</div>`;
                        console.error(error);
                    }
                }
            }

            // Initialize when page loads
            window.addEventListener("DOMContentLoaded", () => {
                // Add debug indicator to title if enabled
                if (SHOW_INDICES) {
                    const h1 = document.querySelector("h1");
                    const indicator = document.createElement("span");
                    indicator.className = "debug-indicator";
                    indicator.textContent = "DEBUG MODE";
                    h1.appendChild(indicator);
                }

                // Parse episode from URL hash
                const { episode } = parseHash(window.location.hash);

                // Highlight the active episode link
                document.querySelectorAll(".episode-link").forEach((link) => {
                    const linkEpisode = parseInt(
                        link.getAttribute("data-episode")
                    );
                    if (linkEpisode === episode) {
                        link.classList.add("active");
                    }
                });

                // Handle episode link clicks
                document.querySelectorAll(".episode-link").forEach((link) => {
                    link.addEventListener("click", (e) => {
                        e.preventDefault();
                        const targetEpisode = parseInt(
                            link.getAttribute("data-episode")
                        );
                        // Navigate to the new episode
                        window.location.hash =
                            targetEpisode === 1 ? "" : `#${targetEpisode}`;
                        window.location.reload();
                    });
                });

                const renderer = new TranscriptRenderer(
                    document.getElementById("container"),
                    episode
                );
                renderer.render();
            });
        </script>
    </body>
</html>
